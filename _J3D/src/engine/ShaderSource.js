// File generated with util/buildShaders.py. Do not edit //

J3D.ShaderSource = {};

J3D.ShaderSource.Background = "//#name Background\n//#author bartekd\n//#include CommonFilterInclude\n//#vertex\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nvarying vec2 vTextureCoord;\nvoid main(void) {\ngl_Position = vec4(aVertexPosition, 0.0, 1.0);\nvTextureCoord = aTextureCoord;\n}\n//#fragment\nuniform sampler2D uTexture;\nvarying vec2 vTextureCoord;\nvoid main(void) {\ngl_FragColor = texture2D(uTexture, vTextureCoord);\n}\n";

J3D.ShaderSource.CopyFilter = "//#name CopyFilter\n//#description All this shader does is to render a texture (typically a render texture) pixel-to-pixel.\n//#description It is useful in effects like Persistence\n//#author bartekd\n//#include CommonFilterInclude\n//#vertex\n//#include BasicFilterVertex\n//#fragment\nuniform sampler2D uTexture;\nvarying vec2 vTextureCoord;\nvoid main(void) {\nvec4 p = texture2D(uTexture, vTextureCoord);\ngl_FragColor = vec4(p.rgb, 1.0);\n}\n";

J3D.ShaderSource.Depth = "//#name Depth\n//#author bartekd\n//#include CommonInclude\n//#vertex\n//#include VertexInclude\nvarying float depth;\nvoid main(void) {\nvec4 p = mMatrix * vec4(aVertexPosition, 1.0);\ngl_Position = pMatrix * vMatrix * p;\ndepth = gl_Position.z/gl_Position.w;\n}\n//#fragment\nvarying float depth;\nvoid main(void) {\nfloat d = 1.0 - depth;\ngl_FragColor = vec4(d, d, d, 1.0);\n}\n";

J3D.ShaderSource.Gouraud = "//#name Gouraud\n//#author bartekd\n//#include CommonInclude\n//#vertex\n//#include VertexInclude\n//#include Lights\nuniform float specularIntensity;\nuniform float shininess;\nvarying vec3 vLight;\nvarying vec2 vTextureCoord;\nvoid main(void) {\nvec4 p = mMatrix * vec4(aVertexPosition, 1.0);\ngl_Position = pMatrix * vMatrix * p;\nvTextureCoord = getTextureCoord(aTextureCoord);\nvec3 n = nMatrix * aVertexNormal;\nvLight = computeLights(p, n, specularIntensity, shininess);\n}\n//#fragment\nuniform vec4 color;\nuniform vec3 emissive;\nuniform sampler2D colorTexture;\nvarying vec3 vLight;\nvarying vec2 vTextureCoord;\nvoid main(void) {\nvec4 tc = texture2D(colorTexture, vTextureCoord);\nvec3 fc = (color.rgb + tc.rgb) * vLight + emissive.rgb;\ngl_FragColor = vec4(fc, clamp(tc.a, 0.0, 1.0));\n}\n";

J3D.ShaderSource.Lightmap = "//#name Lightmap\n//#author bartekd\n//#include CommonInclude\nvarying vec2 vTextureCoord;\nvarying vec2 vTextureCoord2;\nvarying vec4 vPosition;\nvarying vec3 vNormal;\n//#vertex\n//#include VertexInclude\nuniform vec4 lightmapAtlas;\nvoid main(void) {\nvTextureCoord = getTextureCoord(aTextureCoord);\nvTextureCoord2 = aTextureCoord2 * lightmapAtlas.xy + lightmapAtlas.zw;\nvNormal = nMatrix * aVertexNormal;\nvPosition = mMatrix * vec4(aVertexPosition, 1.0);\ngl_Position = pMatrix * vMatrix * vPosition;\ngl_PointSize = 5.0;\n}\n//#fragment\n//#include Lights\nuniform vec4 color;\nuniform sampler2D colorTexture;\nuniform sampler2D lightmapTexture;\nuniform float specularIntensity;\nuniform float shininess;\nvoid main(void) {\nvec4 tc = texture2D(colorTexture, vTextureCoord);\nvec4 lm = texture2D(lightmapTexture, vTextureCoord2);\nfloat si = specularIntensity * tc.r;\nvec3 ltc = computeLights(vPosition, vNormal, si, shininess);\nvec3 lmc = lm.rgb * lm.a;\nif(tc.a < 0.1) discard;\nelse gl_FragColor = vec4(color.rgb * tc.rgb * (ltc + lmc), 1.0);\n}\n";

J3D.ShaderSource.Normal2Color = "//#name Normal2Color\n//#description Simplest shader possible, no includes\n//#author bartekd\nprecision mediump float;\nvarying vec3 vColor;\n//#vertex\nattribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\nvoid main(void) {\ngl_Position = pMatrix * vMatrix * mMatrix * vec4(aVertexPosition, 1.0);\nvColor = normalize( aVertexNormal / 2.0 + vec3(0.5) );\n}\n//#fragment\nvoid main(void) {\ngl_FragColor = vec4(vColor, 1.0);\n}\n";

J3D.ShaderSource.Phong = "//#name Phong\n//#description Classic phong shader\n//#author bartekd\n//#include CommonInclude\n//#vertex\n//#include VertexInclude\nvarying vec4 vPosition;\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\nvoid main(void) {\nvTextureCoord = getTextureCoord(aTextureCoord);\nvNormal = nMatrix * aVertexNormal;\nvPosition = mMatrix * vec4(aVertexPosition, 1.0);\ngl_Position = pMatrix * vMatrix * vPosition;\ngl_PointSize = 5.0;\n}\n//#fragment\n//#include Lights\nuniform vec4 color;\nuniform sampler2D colorTexture;\nuniform bool hasColorTexture;\nuniform float specularIntensity;\nuniform float shininess;\nvarying vec4 vPosition;\nvarying vec3 vLight;\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\nvoid main(void) {\nvec4 tc = color;\nif(hasColorTexture) tc *= texture2D(colorTexture, vTextureCoord);\nvec3 l = computeLights(vPosition, vNormal, specularIntensity, shininess);\ngl_FragColor = vec4(tc.rgb * l, tc.a);\n//gl_FragColor = vec4(l, tc.a);\n}\n";

J3D.ShaderSource.Reflective = "//#name Reflective\n//#description Based on Cg tutorial: http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter07.html\n//#author bartekd\n//#include CommonInclude\nvarying vec3 refVec;\n//#vertex\n//#include VertexInclude\nvoid main(void) {\ngl_Position = mvpMatrix() * vec4(aVertexPosition, 1.0);\nvec3 normal = normalize(nMatrix * aVertexNormal);\nvec3 incident = normalize( (mMatrix * vec4(aVertexPosition, 1.0)).xyz - uEyePosition);\nrefVec = reflect(incident, normal);\n}\n//#fragment\nuniform samplerCube uCubemap;\nvoid main(void) {\ngl_FragColor = textureCube(uCubemap, refVec);\n}\n";

J3D.ShaderSource.Selflit = "//#name Selflit\n//#author bartekd\n//#description A very basic shader that uses a color and/or a texture and no lights\n//#include CommonInclude\n//#vertex\n//#include VertexInclude\nvarying vec2 vTextureCoord;\nvoid main(void) {\ngl_Position = pMatrix * vMatrix * mMatrix * vec4(aVertexPosition, 1.0);\ngl_PointSize = 1.0;\nvTextureCoord = getTextureCoord(aTextureCoord);\n}\n//#fragment\nuniform vec4 color;\nuniform sampler2D colorTexture;\nuniform bool hasColorTexture;\nvarying vec2 vTextureCoord;\nvoid main(void) {\nvec4 tc = color;\nif(hasColorTexture) tc *= texture2D(colorTexture, vTextureCoord);\ngl_FragColor = vec4(tc.rgba);\n}\n";

J3D.ShaderSource.Skybox = "//#name Skybox\n//#author bartekd\n//#include CommonInclude\n//#vertex\n//#include VertexInclude\nuniform float mid;\nvarying vec3 vVertexPosition;\nvoid main(void) {\ngl_Position = pMatrix * vMatrix * vec4(uEyePosition + aVertexPosition * mid, 1.0);\nvVertexPosition = aVertexPosition;\n}\n//#fragment\nuniform samplerCube uCubemap;\nvarying vec3 vVertexPosition;\nvoid main(void) {\ngl_FragColor = textureCube(uCubemap, vVertexPosition);\n}\n";

J3D.ShaderSource.Vignette = "//#name Vignette\n//#author bartekd\n//#vertex\n//#include BasicFilterVertex\n//#fragment\n//#include CommonFilterInclude\nuniform sampler2D uTexture;\nvarying vec2 vTextureCoord;\nvoid main(void) {\nvec2 m = vec2(0.5, 0.5);\nfloat d = distance(m, vTextureCoord) * 1.0;\nvec3 c = texture2D(uTexture, vTextureCoord).rgb * (1.0 - d * d);\ngl_FragColor = vec4(c.rgb, 1.0);\n}\n";

J3D.ShaderSource.BasicFilterVertex = "//#name BasicFilterVertex\n//#description A basic vertex shader for filters that use a full screen quad and have all the logic in fragment shader\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nvarying vec2 vTextureCoord;\nvoid main(void) {\ngl_Position = vec4(aVertexPosition, 0.0, 1.0);\nvTextureCoord = aTextureCoord;\n}\n";

J3D.ShaderSource.CommonFilterInclude = "//#name CommonFilterInclude\n//#description Common uniforms and function for filters\nprecision mediump float;\nuniform float uTime;\nfloat whiteNoise(vec2 uv, float scale) {\nfloat x = (uv.x + 0.2) * (uv.y + 0.2) * (10000.0 + uTime);\nx = mod( x, 13.0 ) * mod( x, 123.0 );\nfloat dx = mod( x, 0.005 );\nreturn clamp( 0.1 + dx * 100.0, 0.0, 1.0 ) * scale;\n}\nfloat brightness(vec3 c) {\nreturn c.r * 0.2126 + c.g * 0.7152 + c.b * 0.0722;\n}\n";

J3D.ShaderSource.CommonInclude = "//#name CommonInclude\n//#description Collection of common uniforms, functions and structs to include in shaders (both fragment and vertex)\nprecision mediump float;\nuniform float uTime;\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat3 nMatrix;\nuniform mat4 pMatrix;\nuniform vec3 uEyePosition;\nuniform vec4 uTileOffset;\nmat4 mvpMatrix() {\nreturn pMatrix * vMatrix * mMatrix;\n}\nmat4 mvMatrix() {\nreturn vMatrix * mMatrix;\n}\nfloat luminance(vec3 c) {\nreturn c.r * 0.299 + c.g * 0.587 + c.b * 0.114;\n}\nfloat brightness(vec3 c) {\nreturn c.r * 0.2126 + c.g * 0.7152 + c.b * 0.0722;\n}\nvec2 getTextureCoord(vec2 uv) {\nreturn uv * uTileOffset.xy + uTileOffset.zw;\n}\n";

J3D.ShaderSource.Lights = "//#name Lights\n//#description Collection of light equations\n//#description Requires CommonInclude\n//#description TODO Separate functions for directional, spot, point, hemi/phong models for all, separate dif func from spec\nstruct lightSource {\nint type;\nvec3 direction;     // used by directional and spotlight (global direction of the transfom)\nvec3 position;      // used by hemisphere, point, spotlight (it's the global position of the transform)\nvec3 color;         // used by d/p/s and hemisphere\nfloat intensity;    // used by spherical harmonics & d/p/s\nfloat angleFalloff; // used by hemisphere and spotlight (TODO: change to falloff)\nfloat angle;        // used by spotlight\n};\nuniform lightSource uLight0;\nuniform lightSource uLight1;\nuniform lightSource uLight2;\nuniform lightSource uLight3;\nconst float C1 = 0.429043;\nconst float C2 = 0.511664;\nconst float C3 = 0.743125;\nconst float C4 = 0.886227;\nconst float C5 = 0.247708;\n//const vec3 L00  = vec3( 0.871297,  0.875222,  0.864470);\n//const vec3 L1m1 = vec3( 0.175058,  0.245335,  0.312891);\n//const vec3 L10  = vec3( 0.034675,  0.036107,  0.037362);\n//const vec3 L11  = vec3(-0.004629, -0.029448, -0.048028);\n//const vec3 L2m2 = vec3(-0.120535, -0.121160, -0.117507);\n//const vec3 L2m1 = vec3( 0.003242,  0.003624,  0.007511);\n//const vec3 L20  = vec3(-0.028667, -0.024926, -0.020998);\n//const vec3 L21  = vec3(-0.077539, -0.086325, -0.091591);\n//const vec3 L22  = vec3(-0.161784, -0.191783, -0.219152);\nconst vec3 L00  = vec3( 0.078908,  0.043710,  0.054161);\nconst vec3 L1m1 = vec3( 0.039499,  0.034989,  0.060488);\nconst vec3 L10  = vec3(-0.033974, -0.018236, -0.026940);\nconst vec3 L11  = vec3(-0.029213, -0.005562,  0.000944);\nconst vec3 L2m2 = vec3(-0.011141, -0.005090, -0.012231);\nconst vec3 L2m1 = vec3(-0.026240, -0.022401, -0.047479);\nconst vec3 L20  = vec3(-0.015570, -0.009471, -0.014733);\nconst vec3 L21  = vec3( 0.056014,  0.021444,  0.013915);\nconst vec3 L22  = vec3( 0.021205, -0.005432, -0.030374);\nvec3 sphericalHarmonics(vec3 n, lightSource ls) {\nvec3 c =  C1 * L22 * (n.x * n.x - n.y * n.y) +\nC3 * L20 * n.z * n.z +\nC4 * L00 -\nC5 * L20 +\n2.0 * C1 * L2m2 * n.x * n.y +\n2.0 * C1 * L21  * n.x * n.z +\n2.0 * C1 * L2m1 * n.y * n.z +\n2.0 * C2 * L11  * n.x +\n2.0 * C2 * L1m1 * n.y +\n2.0 * C2 * L10  * n.z;\nc *= ls.intensity;\nreturn c;\n}\nvec3 hemisphere(vec4 p, vec3 n, float si, float sh, lightSource ls) {\nvec3 lv = normalize(ls.position - p.xyz);\nfloat dif = (dot(n, lv) * 0.5 + 0.5);\ndif = smoothstep(ls.angleFalloff, 1.0-ls.angleFalloff, dif);\nfloat spec = 0.0;\nif(si > 0.0) {\nvec3 eyed = normalize(uEyePosition - p.xyz);\nvec3 refd = reflect(-lv, n);\nspec = pow(max(dot(refd, eyed), 0.0), sh) * si;\n};\nreturn ls.color * dif + ls.color * spec;\n}\nvec3 phong(vec4 p, vec3 n, float si, float sh, lightSource ls){\nvec3 ld;\nif(ls.type == 1) ld = -ls.direction;\nelse ld = normalize(ls.position - p.xyz);\nfloat dif = max(dot(n, ld), 0.0);\nfloat spec = 0.0;\nif(si > 0.0) {\nvec3 eyed = normalize(uEyePosition - p.xyz);\nvec3 refd = reflect(-ld, n);\nspec = pow( (dot(refd, eyed) + 1.0) * 0.5, sh * 4.0) * si;\n}\nif(ls.type == 3) {\nfloat dd = dot(ld, -ls.direction);\nfloat ca = cos(ls.angle);\nfloat cf = cos(ls.angle + ls.angleFalloff);\nfloat spm = smoothstep(cf, ca, dd);\ndif *= spm;\nspec *= spm;\n}\ndif *= ls.intensity;\n//spec *= ls.intensity;\nreturn ls.color * dif + ls.color * spec;\n}\nvec3 singleLight(vec4 p, vec3 n, float si, float sh, lightSource ls) {\nif(ls.type == 0) {\nreturn ls.color;\n} else if(ls.type > 0 && ls.type < 4) {\nreturn phong(p, n, si, sh, ls);\n} else if(ls.type == 4) {\nreturn hemisphere(p, n, si, sh, ls);\n} else if(ls.type == 5) {\nreturn sphericalHarmonics(n, ls);\n} else {\nreturn vec3(0.0, 0.0, 0.0);\n}\n}\nvec3 computeLights(vec4 p, vec3 n, float si, float sh) {\nvec3 s = vec3(0.0, 0.0, 0.0);\ns += singleLight(p, n, si, sh, uLight0);\ns += singleLight(p, n, si, sh, uLight1);\ns += singleLight(p, n, si, sh, uLight2);\ns += singleLight(p, n, si, sh, uLight3);\nreturn s;\n}\n";

J3D.ShaderSource.Modifiers = "//#name Modifiers\n//#description A collection of modifier functions for geometry (only bend for now)\nvec3 bend(vec3 ip, float ba, vec2 b, float o, float a) {\nvec3 op = ip;\nip.x = op.x * cos(a) - op.y * sin(a);\nip.y = op.x * sin(a) + op.y * cos(a);\nif(ba != 0.0) {\nfloat radius = b.y / ba;\nfloat onp = (ip.x - b.x) / b.y - o;\nip.z = cos(onp * ba) * radius - radius;\nip.x = (b.x + b.y * o) + sin(onp * ba) * radius;\n}\nop = ip;\nip.x = op.x * cos(-a) - op.y * sin(-a);\nip.y = op.x * sin(-a) + op.y * cos(-a);\nreturn ip;\n}\n";

J3D.ShaderSource.VertexInclude = "//#name VertexInclude\n//#description Common attributes for a mesh - include this in a vertex shader so you don't rewrite this over and over again\nattribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\nattribute vec2 aTextureCoord;\nattribute vec2 aTextureCoord2;\nattribute vec4 aVertexColor;\n";

